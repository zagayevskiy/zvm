fn lispDef(context: LispRuntimeContext, env: Cons, args: Cons): Cons {
    val key = car(args);
    val evaluatedValue = eval(context, env, cdar(args));
    dictPut(context.mem, envDict(env), key, evaluatedValue);
    return evaluatedValue;
}

fn lispLambda(context: LispRuntimeContext, env: Cons, args: Cons): Cons {
    return makeUserDefinedLambda(context, env, args);
}


# this is TCO fn so it returns (resultBody . newEnv)
fn lispLet(context: LispRuntimeContext, env: Cons, args: Cons): Cons {
    var bindings = car(args);
    if (getType(bindings) == CT_NIL) {
        print("let* with empty bindings list does not make sens.");
    }

    val resultBody = cdar(args);
    if (resultBody == nil) {
        print("let* without body does not make sens. Nil returned.");
        return cons(context.mem, nil, env);
    }

    val mem = context.mem;
    val letEnv = createEnv(mem, env);
    val letEnvDict = envDict(letEnv);

    while(getType(bindings) != CT_NIL) {
        val tail = cdr(bindings);
#        print("let* key:");
#        printCons(key);
#        print("\nlet* value:");
#        printCons(value);
        dictPut(mem, letEnvDict, car(bindings), eval(context, letEnv, car(tail)));
        bindings = cdr(tail);
    }

    return cons(mem, resultBody, letEnv);
}

fn lispPlus(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    var current = car(args);
    assertType(current, CT_INT, "int expected as 1st arg of +");
    var result= getInt(current);
    for (var tail = cdr(args); getType(tail) != CT_NIL; tail = cdr(tail)) {
        current = car(tail);
        assertType(current, CT_INT, "ints expected as args of +");
        result = result + getInt(current);
    }

    return makeNumber(context.mem, result);
}

fn lispMul(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    var current = car(args);
    assertType(current, CT_INT, "int expected as 1st arg of *");
    var result= getInt(current);
    for (var tail = cdr(args); getType(tail) != CT_NIL; tail = cdr(tail)) {
        current = car(tail);
        assertType(current, CT_INT, "ints expected as args of *");
        result = result * getInt(current);
    }

    return makeNumber(context.mem, result);
}

fn lispIsNil(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    if (getType(car(args)) == CT_NIL && getType(cdr(args)) == CT_NIL) {
        return context.atomT;
    }

    return nil;
}

fn lispIsNumber(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    if (getType(car(args)) == CT_INT && getType(cdr(args)) == CT_NIL) {
        return context.atomT;
    }

    return nil;
}

fn lispQuote(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return car(args);
}

fn lispList(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return args;
}

fn lispCons(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cons(context.mem, car(args), cdar(args));
}

fn lispCar(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return car(car(args));
}

fn lispCdr(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cdr(car(args));
}

fn lispCaar(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return caar(car(args));
}

fn lispCadr(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cadr(car(args));
}

fn lispCdar(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cdar(car(args));
}

fn lispCddr(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cddr(car(args));
}

fn lispCaaar(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return caaar(car(args));
}

fn lispCaadr(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return caadr(car(args));
}

fn lispCadar(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cadar(car(args));
}

fn lispCdaar(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cdaar(car(args));
}

fn lispCaddr(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return caddr(car(args));
}

fn lispCddar(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cddar(car(args));
}

fn lispCdadr(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cdadr(car(args));
}

fn lispCdddr(context: LispRuntimeContext, unusedEnv: Cons, args: Cons): Cons {
    return cdddr(car(args));
}