@include<lisp/automem.zc>
@include<lisp/rbtree.zc>

# LispEnv struct
# (Dict . OuterLispEnv)
struct LispRuntimeContext {
    var mem: AutoMemory;
    var globalEnv: Cons;
}

@include<lisp/std_fns.zc>

fn createRuntimeContext(mem: AutoMemory): LispRuntimeContext {
    val context: LispRuntimeContext = alloc(sizeof<LispRuntimeContext>);

    context.mem = mem;
    context.globalEnv = createEnv(mem, nil);

    fillGlobalWithStandardFunctions(context);

    return context;
}

fn freeRuntimeContext(context: LispRuntimeContext) {
    free(context);
}

fn createEnv(mem: AutoMemory, outerEnv: Cons): Cons {
    val dict: Cons = cast<[void]>(makeRbTree(mem));
    return cons(mem, dict, outerEnv);
}

fn envDict(env: Cons): RbTree {
    return cast<[void]>(car(env));
}

fn envOuterEnv(env: Cons): Cons {
    return cdr(env);
}

fn envLookup(env: Cons, key: Cons): Cons {
    var found: Cons = nil;
    var currentEnv = env;
    while (found == nil && currentEnv != nil) {
        found = findTree(envDict(currentEnv).root, key, ::compare);
        currentEnv = envOuterEnv(currentEnv);
    }

    return found;
}

fn fillGlobalWithStandardFunctions(context: LispRuntimeContext) {
    val dict = envDict(context.globalEnv);
    val mem = context.mem;

    putNamedLambda(mem, dict, "+", ::lispPlus, true);
    putNamedLambda(mem, dict, "*", ::lispMul, true);
}

fn eval(context: LispRuntimeContext, currentEnv: Cons, sexpr: Cons): Cons {
    print("eval:");
    printCons(sexpr);
    print("\n");
    val sexprType = getType(sexpr);
    if (sexprType == CT_INT) return sexpr;
    if (sexprType == CT_ATOM) return envLookup(currentEnv, sexpr);

    if (sexprType == CT_LIST) {
        val f = eval(context, currentEnv, car(sexpr));
        val args = cdr(sexpr);
        val regularFnRef = tryGetRegularFnRef(f);
        if (regularFnRef != nil) {
            return callRegularLambda(context, regularFnRef, isEvalArgs(f), currentEnv, args);
        } else {
            crashm(404, "Unknown function");
        }
    }

    return nil;
}

fn mapEval(context: LispRuntimeContext, currentEnv: Cons, list: Cons): Cons {

    var result: Cons = nil;
    var resultCursor = result;
    val mem = context.mem;
    for (var cursor = list; getType(cursor) != CT_NIL; cursor = cdr(cursor)) {
        val current = car(cursor);
        val nextCons = cons(mem, eval(context, currentEnv, current), nil);
        if (result == nil) {
            result = nextCons;
            resultCursor = result;
        } else {
            resultCursor.right = nextCons;
            resultCursor = resultCursor.right;
        }
    }

    return result;
}

fn putNamedLambda(mem: AutoMemory, dict: RbTree, name: [byte], nativeFunction: (LispRuntimeContext, Cons, Cons) -> Cons, evalArgs: bool) {
    dictPut(mem, dict, makeAtom(mem, name), makeRegularLambda(mem, nativeFunction, evalArgs));
}


const REGULAR_LAMBDA_CHECK_MASK = 1431655765; # 0b01010101010101010101010101010101

# returns regular function reference
# or nil if passed cons does not represents regular function reference
fn tryGetRegularFnRef(mayBeLambda: Cons): (LispRuntimeContext, Cons, Cons) -> Cons {
    if (getType(mayBeLambda) != CT_INT) return nil;
    val mayBeFnRef = cast<int>(mayBeLambda.left);
    val check = cast<int>(mayBeLambda.right) ^ REGULAR_LAMBDA_CHECK_MASK;
    if (mayBeFnRef != check) return nil;
    return cast<(LispRuntimeContext, Cons, Cons) -> Cons>(mayBeFnRef);
}

fn makeRegularLambda(mem: AutoMemory, nativeFunction: (LispRuntimeContext, Cons, Cons) -> Cons, evalArgs: bool): Cons {
    val nativeFunctionAddress = cast<int>(nativeFunction);
    val nativeFunctionAddressCheck = nativeFunctionAddress ^ REGULAR_LAMBDA_CHECK_MASK;
    val lambda = makeCons(mem, cast<[void]>(nativeFunctionAddress), cast<[void]>(nativeFunctionAddressCheck), CT_INT);
    setEvalArgs(lambda, evalArgs);
    return lambda;
}

fn callRegularLambda(context: LispRuntimeContext, nativeFunction: (LispRuntimeContext, Cons, Cons) -> Cons, evalArgs: bool, env: Cons, args: Cons): Cons {
    val argsType = getType(args);
    if (argsType != CT_LIST && argsType != CT_NIL) {
        print("list or nil expected as args");
        crash(5);
    }

    var actualArgs: Cons;
    if (evalArgs) {
        actualArgs = mapEval(context, env, args);
    } else {
        actualArgs = args;
    }
    return nativeFunction(context, env, actualArgs);
}

fn dictPut(mem: AutoMemory, dict: RbTree, key: Cons, value: Cons) {
    putRbTree(mem, dict, key, value, ::compare);
}

fn setEvalArgs(lambda: Cons, evalArgs: bool) {
    setUserBit1(lambda, evalArgs);
}

fn isEvalArgs(lambda: Cons): bool {
    return userBit1(lambda);
}