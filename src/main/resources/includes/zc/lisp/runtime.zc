@include<lisp/automem.zc>
@include<lisp/rbtree.zc>

# LispEnv struct
# (Dict . OuterLispEnv)
struct LispRuntimeContext {
    var mem: AutoMemory;
    var globalEnv: Cons;
}

@include<lisp/std_fns.zc>

fn createRuntimeContext(mem: AutoMemory): LispRuntimeContext {
    val context: LispRuntimeContext = alloc(sizeof<LispRuntimeContext>);

    context.mem = mem;
    context.globalEnv = createEnv(mem, nil);

    fillGlobalWithStandardFunctions(context);

    return context;
}

fn freeRuntimeContext(context: LispRuntimeContext) {
    free(context);
}

fn createEnv(mem: AutoMemory, outerEnv: Cons): Cons {
    val dict: Cons = cast<[void]>(makeRbTree(mem));
    return cons(mem, dict, outerEnv);
}

fn envDict(env: Cons): RbTree {
    return cast<[void]>(car(env));
}

fn envOuterEnv(env: Cons): Cons {
    return cdr(env);
}

fn envLookup(env: Cons, key: Cons): Cons {
    var found: Cons = nil;
    var currentEnv = env;
    while (found == nil && currentEnv != nil) {
        found = findTree(envDict(currentEnv).root, key, ::compare);
        currentEnv = envOuterEnv(currentEnv);
    }

    return found;
}

fn fillGlobalWithStandardFunctions(context: LispRuntimeContext) {
    val dict = envDict(context.globalEnv);
    val mem = context.mem;

    putNamedLambda(mem, dict, "+", ::lispPlus, true);
    putNamedLambda(mem, dict, "*", ::lispMul, true);
}

fn eval(context: LispRuntimeContext, currentEnv: Cons, sexpr: Cons): Cons {

}

fn putNamedLambda(mem: AutoMemory, dict: RbTree, name: [byte], nativeFunction: (LispRuntimeContext, Cons, Cons) -> Cons, evalArgs: bool) {
    dictPut(mem, dict, makeAtom(mem, name), makeRegularLambda(mem, nativeFunction, evalArgs));
}


const REGULAR_LAMBDA_CHECK_MASK = 1431655765; # 0b01010101010101010101010101010101

fn isRegularLambda(mayBeLambda: Cons): bool {
    return getType(mayBeLambda) == CT_INT &&
        ((cast<int>(mayBeLambda.right) ^ REGULAR_LAMBDA_CHECK_MASK) == cast<int>(mayBeLambda.left));
}

fn makeRegularLambda(mem: AutoMemory, nativeFunction: (LispRuntimeContext, Cons, Cons) -> Cons, evalArgs: bool): Cons {
    val nativeFunctionAddress = cast<int>(nativeFunction);
    val nativeFunctionAddressCheck = nativeFunctionAddress ^ REGULAR_LAMBDA_CHECK_MASK;
    val lambda = makeCons(mem, cast<[void]>(nativeFunctionAddress), cast<[void]>(nativeFunctionAddressCheck), CT_INT);
    setEvalArgs(lambda, evalArgs);
    return lambda;
}

fn callRegularLambda(context: LispRuntimeContext, lambda: Cons, env: Cons, args: Cons): Cons {
    val nativeFunction = cast<(LispRuntimeContext, Cons, Cons) -> Cons>(lambda.left);
    val argsType = getType(args);
    if (argsType != CT_LIST && argsType != CT_NIL) {
        print("list or nil expected as args");
        crash(5);
    }

    var actualArgs: Cons;
    if (isEvalArgs(lambda) && getType(args) != CT_NIL) {
        val mem = context.mem;
        actualArgs = cons(mem, eval(context, env, car(args)), nil);
        var cursor = cdr(args);
        var resultCursor = actualArgs;
        while(getType(cursor) == CT_LIST) {
            resultCursor.right = cons(mem, eval(context, env, car(cursor)), nil);
            resultCursor = resultCursor.right;
            cursor = cdr(cursor);
        }
        assertType(cursor, CT_NIL, "nil expected at the end of args list");
    } else {
        actualArgs = args;
    }
    return nativeFunction(context, env, actualArgs);
}



fn plus(l: int, r: int): int {
    return l + r;
}

#fn putFunction(mem: AutoMemory, env: Cons, name: [byte], function: ...->...)

fn dictPut(mem: AutoMemory, dict: RbTree, key: Cons, value: Cons) {
    putRbTree(mem, dict, key, value, ::compare);
}

fn setEvalArgs(lambda: Cons, evalArgs: bool) {
    setUserBit1(lambda, evalArgs);
}

fn isEvalArgs(lambda: Cons): bool {
    return userBit1(lambda);
}